#include <config.h>

#include <algorithm>
#include <cmath>
#include <format>
#include <functional>
#include <ranges>
#include <stdexcept>
#include <string>
#include <string_view>
#include <vector>

#include <common/common.hpp>
#include <utils/cmd.hpp>
#include <utils/strconv.hpp>
#include <utils/types.hpp>

using namespace std::literals::string_literals;
using namespace std::literals::string_view_literals;
using namespace ADVENT_OF_CODE_CPP_NAMESPACE;

[[nodiscard]] static std::string SolvePart1(std::string_view input) {
    auto result = std::ranges::fold_left(
        input | std::views::split('\n') | std::views::filter([](auto&& record) {
            return !record.empty();
        }) | std::views::transform([](auto&& record) {
            const auto record_sv = std::string_view(record);
            const auto diag_pos  = record_sv.find(']');
            if (diag_pos == std::string::npos) {
                throw std::invalid_argument(std::format("Invalid input: {}", record_sv));
            }

            std::uint64_t diagram = 0;
            for (auto [i, ch] :
                 std::string_view {record_sv.begin() + 1, record_sv.begin() + diag_pos} | std::views::enumerate) {
                diagram |= (((std::uint64_t)ch == '#' ? 1 : 0) << i);
            }

            const auto joltage_req_pos = record_sv.find('{');
            if (joltage_req_pos == std::string::npos) {
                throw std::invalid_argument(std::format("Invalid input: {}", record_sv));
            }

            const auto schema_sv =
                std::string_view {record_sv.begin() + diag_pos + 1, record_sv.begin() + joltage_req_pos};
            const auto buttons =
                schema_sv | std::views::split(' ') | std::views::filter([](auto&& line) {
                    return !line.empty();
                }) |
                std::views::transform([](auto&& line) {
                    const auto line_sv = std::string_view(line);
                    if (line_sv.front() != '(' || line_sv.back() != ')') {
                        throw std::invalid_argument(std::format("Invalid button schema: {}", line_sv));
                    }
                    const auto    button_sv  = std::string_view {line_sv.begin() + 1, line_sv.end() - 1};
                    std::uint64_t press_mask = 0;
                    std::ranges::for_each(
                        button_sv | std::views::split(',') | std::views::transform([](auto&& number) {
                            return utils::StringViewToIntegral<std::uint64_t>(std::string_view(number));
                        }),
                        [&press_mask](std::uint64_t number) {
                            press_mask |= (1u << number);
                        });
                    return press_mask;
                }) |
                std::ranges::to<std::vector<std::uint64_t>>();

            std::size_t min_npress = buttons.size() + 1uz;

            const auto mask_end = 1uz << buttons.size();
            for (auto mask = 0uz; mask < mask_end; ++mask) {
                std::uint64_t current_diag = 0;

                auto current_mask = mask;
                auto npress       = 0uz;
                while (current_mask != 0) {
                    const auto lowest_set_bit = current_mask & -current_mask;
                    const auto button_index   = (std::size_t)__builtin_ctzll(lowest_set_bit);
                    current_diag ^= buttons[button_index];
                    current_mask &= ~lowest_set_bit;
                    ++npress;
                }
                if (current_diag == diagram && npress < min_npress) {
                    min_npress = npress;
                }
            }
            return min_npress;
        }),
        0uz, std::plus {});
    return std::to_string(result);
}

constexpr std::string_view kPythonCode = R"(
"""
This Python code is generated by Gemini: https://gemini.google.com/
"""

import numpy as np
from scipy.optimize import milp, LinearConstraint, Bounds

def solve_with_scipy(A, b):
    n_vars = A.shape[1]
    
    # 1. Objective function coefficients 'c'
    # We want to minimize sum(x), which is equivalent to minimizing (1*x0 + 1*x1 + ... + 1*xn)
    # Therefore, the coefficient vector c consists of all 1s.
    c = np.ones(n_vars)
    
    # 2. Constraints Ax = b
    # In 'milp', equality constraints are defined as: b_lower <= Ax <= b_upper
    # When b_lower == b_upper, it acts as an equality constraint.
    A_eq = A
    b_eq = b
    constraints = LinearConstraint(A_eq, lb=b_eq, ub=b_eq)
    
    # 3. Variable type constraints (integrality)
    # 0 indicates a continuous variable, 1 indicates an integer variable.
    # We require all variables to be integers.
    integrality = np.ones(n_vars) 
    
    # 4. Variable bounds
    # x >= 0 (Lower bound is 0, upper bound is infinity)
    bounds = Bounds(lb=0, ub=np.inf)
    
    # 5. Solve the problem
    res = milp(c=c, constraints=constraints, integrality=integrality, bounds=bounds)
    
    if res.success:
        # res.x returns floats, so we convert them back to integers.
        # Rounding is used to handle potential floating-point inaccuracies.
        result_x = np.round(res.x).astype(int)
        min_sum = np.sum(result_x)
        return result_x, min_sum
    else:
        return None, None

# --- Solve ---
if __name__ == "__main__":
    As = [
        {}
    ]
    bs = [
        {}
    ]

    result = 0
    for A, b in zip(As, bs):
        x, s = solve_with_scipy(A, b)

        if x is not None:
            result += s
            print(f"Optimal Solution x: {{x}}")
            print(f"Minimum Sum: {{s}}")
        else:
            print("No solution found.")
    print(f"Final result: {{result}}")
)"sv;

[[nodiscard]] static std::string SolvePart2(std::string_view input) {
    const auto data =
        input | std::views::split('\n') | std::views::filter([](auto&& record) {
            return !record.empty();
        }) |
        std::views::transform([](auto&& record) {
            const auto record_sv = std::string_view(record);
            const auto diag_pos  = record_sv.find(']');
            if (diag_pos == std::string::npos) {
                throw std::invalid_argument(std::format("Invalid input: {}", record_sv));
            }

            const auto joltage_req_pos = record_sv.find('{');
            if (joltage_req_pos == std::string::npos) {
                throw std::invalid_argument(std::format("Invalid input: {}", record_sv));
            }

            const auto schema_sv =
                std::string_view {record_sv.begin() + diag_pos + 1, record_sv.begin() + joltage_req_pos};
            const auto buttons =
                schema_sv | std::views::split(' ') | std::views::filter([](auto&& line) {
                    return !line.empty();
                }) |
                std::views::transform([](auto&& line) {
                    const auto line_sv = std::string_view(line);
                    if (line_sv.front() != '(' || line_sv.back() != ')') {
                        throw std::invalid_argument(std::format("Invalid button schema: {}", line_sv));
                    }
                    const auto button_sv = std::string_view {line_sv.begin() + 1, line_sv.end() - 1};
                    return button_sv | std::views::split(',') | std::views::transform([](auto&& number) {
                               return utils::StringViewToIntegral<std::uint64_t>(std::string_view(number));
                           });
                }) |
                std::ranges::to<std::vector<std::vector<std::uint64_t>>>();

            const auto joltage_req_end = record_sv.find('}');
            if (joltage_req_end == std::string_view::npos) {
                throw std::invalid_argument(std::format("Invalid input: {}", record_sv));
            }
            const auto joltage_sv =
                std::string_view {record_sv.begin() + joltage_req_pos + 1, record_sv.begin() + joltage_req_end};
            const auto joltage_req = joltage_sv | std::views::split(',') | std::views::transform([](auto&& number) {
                                         return utils::StringViewToIntegral<std::size_t>(std::string_view(number));
                                     }) |
                                     std::ranges::to<std::vector<std::size_t>>();
            const auto joltage_req_fmt = "np.array(["s +
                                         (joltage_req | std::views::transform([](std::uint64_t number) {
                                              return std::to_string(number);
                                          }) |
                                          std::views::join_with(", "sv) | std::ranges::to<std::string>()) +
                                         "])"s;

            auto buttons_matrix = std::vector<std::vector<std::uint64_t>>(
                joltage_req.size(), std::vector<std::uint64_t>(buttons.size(), 0));
            for (auto i = 0uz; i < buttons.size(); ++i) {
                for (auto j = 0uz; j < buttons[i].size(); ++j) {
                    buttons_matrix[buttons[i][j]][i] = 1;
                }
            }
            const auto buttons_fmt = "np.array(["s +
                                     (buttons_matrix | std::views::transform([](const auto& row) {
                                          return "["s +
                                                 (row | std::views::transform([](std::uint64_t number) {
                                                      return std::to_string(number);
                                                  }) |
                                                  std::views::join_with(", "sv) | std::ranges::to<std::string>()) +
                                                 "]"s;
                                      }) |
                                      std::views::join_with(", "sv) | std::ranges::to<std::string>()) +
                                     "])"s;

            return std::make_pair(std::move(buttons_fmt), std::move(joltage_req_fmt));
        }) |
        std::ranges::to<std::vector<std::pair<std::string, std::string>>>();

    const auto As = data | std::views::transform([](const auto& p) {
                        return p.first;
                    }) |
                    std::views::join_with(", "sv) | std::ranges::to<std::string>();
    const auto bs = data | std::views::transform([](const auto& p) {
                        return p.second;
                    }) |
                    std::views::join_with(", "sv) | std::ranges::to<std::string>();
    return std::format(kPythonCode, As, bs);
}

static std::string Solve(std::uint64_t part, std::string_view input) {
    return part == 1 ? SolvePart1(input) : SolvePart2(input);
}

ADVENT_OF_CODE_CPP_MAIN_FUNCTION(2025, 10, Solve)
